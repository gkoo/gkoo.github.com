---
layout: post
title: Backbone's Hard Dependency on jQuery
category: blog
---
<p>There have been a <a href="http://snook.ca/archives/javascript/going-simple-with-javascript">couple</a> of <a href="http://mike.teczno.com/notes/bandwidth.html">posts</a> on Hacker News recently about reducing page bloat by cutting out jQuery.</p>

<p>I thought about my homepage, which included Underscore, Backbone, and jQuery. I realized that the features of jQuery that I use could actually be replaced by simple vanilla Javascript. After all, I mainly use jQuery to add and remove classes, and Backbone&rsquo;s only hard dependency is Underscore, right? I&rsquo;m not so worried about IE6 users, since I can probably count the number of monthly visitors to my site on one hand&mdash;one of which is me&mdash;and I doubt that they use legacy browsers. So I decided to do some spring cleaning and get rid of the magic dollar sign.</p>

<p>As it turns out, Backbone relies on jQuery for quite a lot of its functionality as well. Maybe it was naive of me to think that Backbone implemented its own event delegation when jQuery had already invented that wheel. But let&rsquo;s take a look at what Backbone actually needs jQuery for.</p>

<p class="quote">For RESTful persistence, history support via Backbone.Router and DOM manipulation with Backbone.View, include json2.js, and either jQuery ( > 1.4.2) or Zepto.</p>

<h2>RESTful persistence</h2>
<p>Backbone models and collections can be synced with the server via <a href="http://documentcloud.github.com/backbone/#Model-fetch">fetch</a>, <a href="http://documentcloud.github.com/backbone/#Model-save">save</a>, and <a href="http://documentcloud.github.com/backbone/#Model-destroy">destroy</a> methods. These methods all delegate to the <code>Backbone.sync</code> function, which wraps jQuery&rsquo;s <code>$.ajax</code> function and calls GET, POST, and DELETE methods for the respective Backbone model persistence methods. No big deal here. The only &ldquo;model persistence&rdquo; I really do is make a Posterous API call to fetch my blog posts via JSONP. I can just create a script element, assign the API URL in the script src attribute, and inject it myself.</p>

<h4>History support via Backbone.Router</h4>

<p>A call to <a href="http://documentcloud.github.com/backbone/#History-start">Backbone.History.start</a> uses jQuery to bind a <code>popstate</code> or <code>hashchange</code> event listener to the <code>window</code> object. <code>Backbone.History.stop</code> uses jQuery conversely to unbind these event listeners. No problem. I know how to add event listeners on DOM elements: <code>window.addEventListener</code>. Done.</p>

<h4>DOM manipulation with Backbone.View</h4>

<p>Here&rsquo;s my beef with Backbone. The documentation understates the extent to which Backbone Views depend on jQuery. One of the new features of Backbone is that all Views, in addition to the regular <code>el</code> property which represents the DOM element associated with the View, also get a <code>$el</code> property which holds the jQuery object for that DOM element. That sounds reasonable enough. In the past, I&rsquo;ve actually just assigned the jQuery object into the <code>el</code> object for convenience, so giving it its own property seems logical.</p>

<p>Since Backbone claims its only hard dependency is Underscore and that jQuery is only needed for DOM manipulation, I thought that it would check for the existence of jQuery and only create the <code>$el</code> property if it found that jQuery existed on the page. To my surprise, <em>Backbone Views cannot be created without jQuery</em>. The following code results in a Javascript error:</p>

<div class="CodeRay">
  <div class="code"><pre><span class="tag">&lt;html&gt;</span>
  <span class="tag">&lt;head&gt;</span>
    <span class="tag">&lt;title&gt;</span>My Test Backbone App<span class="tag">&lt;/title&gt;</span>
  <span class="tag">&lt;/head&gt;</span>
  <span class="tag">&lt;body&gt;</span>
    <span class="tag">&lt;div</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">test</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span><span class="tag">&lt;/div&gt;</span>
    <span class="tag">&lt;script</span> <span class="attribute-name">src</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">underscore-min-1.3.1.js</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span><span class="tag">&lt;/script&gt;</span>
    <span class="tag">&lt;script</span> <span class="attribute-name">src</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">backbone.js</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span><span class="tag">&lt;/script&gt;</span>
    <span class="tag">&lt;script&gt;</span>
<span class="inline">      <span class="keyword">var</span> TestView = Backbone.View.extend({
        <span class="key">el</span>: document.getElementById(<span class="string"><span class="delimiter">'</span><span class="content">test</span><span class="delimiter">'</span></span>)
      }),
      test = <span class="keyword">new</span> TestView();</span>
    <span class="tag">&lt;/script&gt;</span>
  <span class="tag">&lt;/body&gt;</span>
<span class="tag">&lt;/html&gt;</span></pre></div>
</div>


<p>All I&rsquo;m doing here is literally just creating a Backbone View attached to a div element. That&rsquo;s it. Backbone complains because it blindly tries to set the <code>TestView.$el</code> property without checking if jQuery even exists on the page. The offending function is View.setElement:</p>

<div class="CodeRay">
  <div class="code"><pre><span class="comment">// Change the view's element (`this.el` property), including event</span>
<span class="comment">// re-delegation.</span>
<span class="function">setElement</span>: <span class="keyword">function</span>(element, delegate) {
  <span class="local-variable">this</span>.<span class="predefined">$el</span> = <span class="predefined">$</span>(element);
  <span class="local-variable">this</span>.el = <span class="local-variable">this</span>.<span class="predefined">$el</span>[<span class="integer">0</span>];
  <span class="keyword">if</span> (delegate !== <span class="predefined-constant">false</span>) <span class="local-variable">this</span>.delegateEvents();
  <span class="keyword">return</span> <span class="local-variable">this</span>;
}</pre></div>
</div>


<p>Not surprisingly, the first line of setElement will throw an exception with the message &ldquo;undefined is not a function.&rdquo;</p>

<p>You could make the argument that Backbone applications can consist of models, collections, no model persistence, no history support, and ad hoc DOM manipulation instead of Backbone Views. But that&rsquo;s extremely far-fetched. I have no idea how many Backbone applications include Views, but my guess would be 99% or up. Backbone&rsquo;s own description of the framework involves separating data from DOM elements by assigning responsibilities to Models and Views, respectively. So if Views cannot exist without jQuery, why does Backbone still claim Underscore as its only hard dependency? At the least, it seems disingenuous.</p>

